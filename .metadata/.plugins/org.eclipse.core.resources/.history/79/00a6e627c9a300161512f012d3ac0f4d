package com.example.networkconnect;

import android.net.NetworkInfo;
import android.net.NetworkInfo.State;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiConfiguration.KeyMgmt;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.util.Log;

public class RKAccessPoint {

	public static final int SECURITY_NONE = 0;
	public static final int SECURITY_WEP = 1;
	public static final int SECURITY_PSK = 2;
	public static final int SECURITY_EAP = 3;
	
	private static final int PSK_UNKNOWN = 0;
    private static final int PSK_WPA = 1;
    private static final int PSK_WPA2 = 2;
    private static final int PSK_WPA_WPA2 = 3;

	public static final int INVALID_NETWORK_ID = -1;

	public String ssid;
	public String bssid;
	public int security;
	public int networkId;
	private int pskType = PSK_UNKNOWN;
	private WifiConfiguration mConfig;
	private NetworkInfo mNetworkInfo;
	private int mRssi;
	private WifiInfo mInfo;

	public void update(ScanResult result) {

	}

	public void update(WifiConfiguration config) {

	}

	public void update(WifiConfiguration config, WifiInfo info,
			NetworkInfo networkInfo) {

	}

	static int getSecurity(WifiConfiguration config) {
		if (config.allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
			return SECURITY_PSK;
		}
		if (config.allowedKeyManagement.get(KeyMgmt.WPA_EAP)
				|| config.allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
			return SECURITY_EAP;
		}
		return (config.wepKeys[0] != null) ? SECURITY_WEP : SECURITY_NONE;
	}
	
	private static int getPskType(ScanResult result) {
        boolean wpa = result.capabilities.contains("WPA-PSK");
        boolean wpa2 = result.capabilities.contains("WPA2-PSK");
        if (wpa2 && wpa) {
            return PSK_WPA_WPA2;
        } else if (wpa2) {
            return PSK_WPA2;
        } else if (wpa) {
            return PSK_WPA;
        } else {
            return PSK_UNKNOWN;
        }
    }

	private static int getSecurity(ScanResult result) {
		if (result.capabilities.contains("WEP")) {
			return SECURITY_WEP;
		} else if (result.capabilities.contains("PSK")) {
			return SECURITY_PSK;
		} else if (result.capabilities.contains("EAP")) {
			return SECURITY_EAP;
		}
		return SECURITY_NONE;
	}

	public String convertToQuotedString(String string) {
		return "\"" + string + "\"";
	}

	protected void generateOpenNetworkConfig() {
		if (security != SECURITY_NONE)
			throw new IllegalStateException();
		if (mConfig != null)
			return;
		mConfig = new WifiConfiguration();
		mConfig.SSID = convertToQuotedString(ssid);
		mConfig.allowedKeyManagement.set(KeyMgmt.NONE);
	}

	public int compareTo(RKAccessPoint other) {
		// Active one goes first.
		if (isActive() && !other.isActive())
			return -1;
		if (!isActive() && other.isActive())
			return 1;

		// Reachable one goes before unreachable one.
		if (mRssi != Integer.MAX_VALUE && other.mRssi == Integer.MAX_VALUE)
			return -1;
		if (mRssi == Integer.MAX_VALUE && other.mRssi != Integer.MAX_VALUE)
			return 1;

		// Configured one goes before unconfigured one.
		if (networkId != INVALID_NETWORK_ID
				&& other.networkId == INVALID_NETWORK_ID)
			return -1;
		if (networkId == INVALID_NETWORK_ID
				&& other.networkId != INVALID_NETWORK_ID)
			return 1;

		// Sort by signal strength.
		int difference = WifiManager.compareSignalLevel(other.mRssi, mRssi);
		if (difference != 0) {
			return difference;
		}
		// Sort by ssid.
		return ssid.compareToIgnoreCase(other.ssid);
	}

	@Override
	public int hashCode() {
		int result = 0;
		if (mInfo != null)
			result += 13 * mInfo.hashCode();
		result += 19 * mRssi;
		result += 23 * networkId;
		result += 29 * ssid.hashCode();
		return result;
	}

	@Override
	public boolean equals(Object other) {
		if (!(other instanceof RKAccessPoint))
			return false;
		return (this.compareTo((RKAccessPoint) other) == 0);
	}

	public boolean isActive() {
		return mNetworkInfo != null
				&& (networkId != INVALID_NETWORK_ID || mNetworkInfo.getState() != State.DISCONNECTED);
	}
}
