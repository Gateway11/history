package com.rokid.rksettings;

import java.io.IOException;

import android.os.RemoteException;
import android.os.Parcel;
import android.os.Binder;
import android.os.IBinder;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import rokid.services.util.RemoteServiceHelper;
import rokid.os.IRKAccountManagerInternal;

import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import java.util.Locale;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;

import org.json.JSONObject;

import com.rokid.rksettings.interfac.IRKWifiManager;
import com.rokid.rksettings.interfac.IRKWifiManagerCallback;
import com.rokid.rksettings.wifi.RKWifiManagerService;
import android.text.TextUtils;

public class RKSettingsServices extends Service {

	private final String TAG = "RKSettingsServices";
	private final String QR_SCAN_BACK_ACTION = "com.rokid.wifi.scan_result";

	public static final int MESSAGE_INIT_SERVICE = 0;
	public static final int MESSAGE_LOGIN_SUCCESS = 1;
	public static final int MESSAGE_LOGIN_FAIL = 2;
	public static final int MESSAGE_BINDMASTER_SUCCESS = 3;
	public static final int MESSAGE_BINDMASTER_FAIL = 4;
	public static final int MESSAGE_UNBINDMASTER_SUCCESS = 5;
	public static final int MESSAGE_UNBINDMASTER_FAIL = 6;
	public static final int MESSAGE_GO_SCAN_CODE=7;
	public static final int MESSAGE_PALY_AUDIO=8;
	public static final int MESSAGE_HANDLE_NLP=9;
	public static final int MESSAGE_HANDLE_QR_RESULT=10;
	public static final int MESSAGE_HANDLE_WHERE_IS_ROKID=11;
//	public static final int MESSAGE_HANDLE_RELOGIN=12;
	public static final int MESSAGE_SEND_EVENT_TO_FAKE_QR=13;
	public static final int MESSAGE_HANDLE_REPORT_TO_PHONE=14;

	private IRKAccountManagerInternal mAccountManager;
	private IRKWifiManager mWifiManager;
	private RKSettingsServicesProxy mProxy;
	private SettingsExts mSettingsExts;
	private WifiManagerCallback wifiCallback;

	private ReentrantLock connectedLock;
	private Condition connectedCondition;
	
	private static boolean bindMasterFailed = false;
	private static boolean unbindMasterFailed = false;
	private static boolean loginFailed = false;
	private static boolean waited=false;
	private AtomicBoolean mBootProgress = new AtomicBoolean(true);
	protected int loginFailureNum;

	private Handler mHandler = new Handler(){
		public void handleMessage(android.os.Message msg) {
			switch (msg.what) {
			case MESSAGE_INIT_SERVICE:
				initService();
				break;
			case MESSAGE_LOGIN_SUCCESS:
				handleLoginSuccess();
				break;
			case MESSAGE_LOGIN_FAIL:
				handleLoginFail();
				break;
			case MESSAGE_BINDMASTER_SUCCESS:
				handleBindMasterSuccess((String)msg.obj);
				break;
			case MESSAGE_BINDMASTER_FAIL:
				handleBindMasterFail((String)msg.obj);
				break;
			case MESSAGE_UNBINDMASTER_SUCCESS:
				handleUnbindMasterSuccess();
				break;
			case MESSAGE_UNBINDMASTER_FAIL:
				handleUnbindMasterFail((String)msg.obj);
				break;
			case MESSAGE_GO_SCAN_CODE:
				break;
			case MESSAGE_HANDLE_QR_RESULT:
				mLastMasterId = mSettingsExts.handleQRResultProcess((String)msg.obj,mWifiManager);
				break;
			case MESSAGE_HANDLE_WHERE_IS_ROKID:
				mSettingsExts.syncLocationInfo((String)msg.obj);
				break;
			case MESSAGE_SEND_EVENT_TO_FAKE_QR:
				mSettingsExts.sendEventToFakeQR((String)msg.obj);
				break;
			case MESSAGE_HANDLE_REPORT_TO_PHONE:
				Bundle data = msg.getData();
				mSettingsExts.reportToPhone(data.getString("who"), data.getString("arg"),mAccountManager);
				break;
			case MESSAGE_HANDLE_NLP:
				handleNLP((String)msg.obj);
				break;
			}
		}
	};
	
	IBinder callback = new Binder(){
		
	};

	private String mLastMasterId;
	private BroadcastReceiver receiver=new BroadcastReceiver(){
		public void onReceive(Context context, Intent intent) {
			String event = intent.getStringExtra("event");
			if (event.equals("qrResultDone")) {
				String result = intent.getStringExtra("result");
				mHandler.obtainMessage(MESSAGE_HANDLE_QR_RESULT, result).sendToTarget();
			} else if (event.equals("connectionDone")) {
				Log.i(TAG, "scan complete connectionDone ...");
				if(loginFailed){
					if(mAccountManager!=null){
						mSettingsExts.doLogin(mAccountManager);
					}
				}
			}
		}
	};
	
	private SettingsMapper mSettingsMapper;

	public Handler getHandler() {
		return mHandler;
	}
	
	public IBinder getBinder(){
		return mProxy;
	}
	
	public void updateUnbindId(String masterId) {
    	this.mLastMasterId = masterId;
    }

	@Override
	public void onCreate() {
		bindWifiService();
		registerReceiver(receiver, new IntentFilter(QR_SCAN_BACK_ACTION));
		wifiCallback = new WifiManagerCallback();
		mSettingsExts = SettingsExts.asInstance(this);
		connectedLock = new ReentrantLock();
		connectedCondition = connectedLock.newCondition();
	}

	@Override
	public IBinder onBind(Intent intent) {
		mProxy = new RKSettingsServicesProxy(this);
		initService();
		return mProxy;
	}

	public void initService() {
		mAccountManager = (IRKAccountManagerInternal) RemoteServiceHelper.getService(RemoteServiceHelper.RK_ACCOUNT);
		mSettingsMapper = new SettingsMapper(this);
		mSettingsMapper.callMustServices();
		registerCallback();
	}

	private void bindWifiService() {
		bindService(new Intent(this,RKWifiManagerService.class), conn, Context.BIND_AUTO_CREATE);
	}
	
	ServiceConnection conn=new ServiceConnection(){

		@Override
		public void onServiceConnected(ComponentName arg0, IBinder arg1) {
			Log.e(TAG,"service connect ");
			mWifiManager=(IRKWifiManager)arg1;
			mWifiManager.setWifiStatusListener(wifiCallback);
		}

		@Override
		public void onServiceDisconnected(ComponentName arg0) {
			
		}
	};

	public boolean checkNetwork() {
		WifiManager mAndroidWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
		List<WifiConfiguration> configurations = mAndroidWifiManager.getConfiguredNetworks();
		if (configurations.isEmpty()) {
			mHandler.sendEmptyMessage(MESSAGE_GO_SCAN_CODE);
		}
		while(true){
			if (mWifiManager.isWifiConnected()) {
				break;
			}
			try{
				Thread.sleep(500);
			}catch (Exception e) {
				e.printStackTrace();
			}
		}
		Log.i(TAG, "Wifi is connected!");
		mSettingsExts.updateLanguage();
		return true;
	}

	public boolean login() {
		if(mAccountManager!=null){
			mSettingsExts.doLogin(mAccountManager);
			waitting();
			return true;
		}
		Log.e(TAG, "mAccountManager is null");
		return false;
	}
	
	public boolean bindMaster() {
		if(mAccountManager!=null){
			mSettingsExts.doBindMaster(mAccountManager);
			waitting();
			return true;
		}
		Log.e(TAG, "mAccountManager is null");
		return false;
	}

	public boolean unbindMaster() {
		if (mAccountManager != null) {
			try {
				mAccountManager.unbindMaster(mSettingsExts.getMaster());
			} catch (RemoteException e) {
				e.printStackTrace();
			}
//			waitting();
		}
		return true;
	}

	public void registerCallback() {
		if (mAccountManager != null) {
			try {
				mAccountManager.registerCallback(mProxy);
			} catch (RemoteException e) {
				e.printStackTrace();
			}
		}
	}

	public void unregisterCallback() {
		if (mAccountManager != null) {
			try {
				mAccountManager.unregisterCallback();
			} catch (RemoteException e) {
				e.printStackTrace();
			}
		}
	}

	public void handleLoginSuccess() {
		connectedLock.lock();
		loginFailed = false;
		try {
			connectedCondition.signal();
		} finally {
			connectedLock.unlock();
		}
		if(bindMasterFailed){
			mSettingsExts.doBindMaster(mAccountManager);
		}
		String mSessionId = null;
    	try {
            mSessionId = mAccountManager.getRokidLoginSessionId();
        } catch (RemoteException e) {
            mSessionId = null;
            e.printStackTrace();
            return;
        }
		mHandler.obtainMessage(MESSAGE_HANDLE_WHERE_IS_ROKID, mSessionId).sendToTarget();
	}

	public void handleLoginFail() {
		loginFailed = true;
		mSettingsExts.speak(R.string.login_failed, 0);
		doRelogin();
	}

	public void handleBindMasterSuccess(String masterId) {
		connectedLock.lock();
		bindMasterFailed = false;
		try {
			connectedCondition.signal();
		} finally {
			connectedLock.unlock();
		}
		mSettingsExts.confirmFirstBoot();
		if (mLastMasterId != null) {
    		if (!mLastMasterId.equals(masterId)) {
    			Log.e(TAG, "WTF scanMasterId is " + mLastMasterId + " masterId is " + masterId + " but bind successfully");
    		}
    		Log.i(TAG, "success with new master id");
    		mSettingsExts.setMaster(mLastMasterId);
    	} 
		mSettingsExts.reportBindMasterStatus(mLastMasterId, SettingsExts.BIND_REASON_OK_SUCCESS);
    	mLastMasterId = null;
	}
	
	public void handleBindMasterFail(String masterId) {
		bindMasterFailed = true;
		mSettingsExts.confirmFirstBoot();
    	String savedMasterId = mSettingsExts.getMaster();
    	if (mLastMasterId == null) {
    		Log.i (TAG, "last is null!");
    		if (masterId != null) {
    			if (savedMasterId != null) {
    				if (savedMasterId.equals(masterId)) {
    					Log.i(TAG, "ok we are the same...");
    	    			mSettingsExts.reportBindMasterStatus(savedMasterId, SettingsExts.BIND_REASON_OK_MASTER_BINDED);
    				} else {
    					Log.w(TAG, "bind master failed, master id not match!");
    					bindMasterFailed=false;
    					mSettingsExts.setMaster(masterId);
    					mSettingsExts.speak(R.string.bind_master_failed2, 5000);
    	    			mSettingsExts.reportBindMasterStatus(savedMasterId, SettingsExts.BIND_REASON_FAILED_MASTER_NOT_MATCH);
    				}
    			//null saved master id 
    			//mLast id is null
    			//rebind!	
    			} else {
    				Log.e(TAG, "empty master id with failed " + masterId);
    				bindMasterFailed=true;
    				mSettingsExts.speak(R.string.bind_master_failed, 5000);
    	    		mHandler.sendEmptyMessage(MESSAGE_GO_SCAN_CODE);
    			}
    		} else {
    			//master id is null 
    			//mLaster id is null
    			Log.e(TAG, "empty master id with failed " + masterId);
    			bindMasterFailed = true;
    			mSettingsExts.speak(R.string.bind_master_failed, 5000);
	    		mHandler.sendEmptyMessage(MESSAGE_GO_SCAN_CODE);
    		}
    	//we have a new masterId
    	//but failed...
    	//let's see what happened..	
    	} else {
    		Log.i (TAG, "last is not null!");
    		//don't check saved id
    		//we have saved id because we disconnect wifi and recv a new one.
    		if (masterId != null) {
    			//ok we are same
    			if (masterId.equals(mLastMasterId)) {
    				//remember the last one
    				bindMasterFailed=false;
    				mSettingsExts.setMaster(mLastMasterId);
    				//clean it
    				mSettingsExts.reportBindMasterStatus(mLastMasterId, SettingsExts.BIND_REASON_OK_MASTER_BINDED);
    				mLastMasterId = null;
	            //not the same, don't change anything   
	            //ok!    
    			} else {
    				Log.w(TAG, "bind master failed, master id not match!");
    				bindMasterFailed=false;
    				mSettingsExts.setMaster(masterId);
    				mSettingsExts.speak(R.string.bind_master_failed2, 5000);
	    			mSettingsExts.reportBindMasterStatus(mLastMasterId, SettingsExts.BIND_REASON_FAILED_MASTER_NOT_MATCH);
	    			mLastMasterId = null;
    			}
    		//master id is null
    		//mLaster id is not null
    		//and failed
    		//go back scan again	
    		} else {
    			Log.e(TAG, "failed with master id is null, mLast is " + mLastMasterId + " saved is " + savedMasterId);
    			mSettingsExts.speak(R.string.bind_master_failed, 5000);
	        	mLastMasterId = null;
	        	bindMasterFailed = true;
	    		mHandler.sendEmptyMessage(MESSAGE_GO_SCAN_CODE);
    		}
    	}
	}

	public void handleUnbindMasterSuccess() {
		connectedLock.lock();
		unbindMasterFailed=false;
//		try {
//			connectedCondition.signal();
//		} finally {
//			connectedLock.unlock();
//		}
		String lastId = mLastMasterId != null ? mLastMasterId : mSettingsExts.getMaster();
		mSettingsExts.clearMaster();
		mSettingsExts.speak(R.string.unbind_successful, 0);
		mLastMasterId = null;
		mSettingsExts.reportUnbindMaster(lastId, true);
	}

	public void handleUnbindMasterFail(String masterId) {
		unbindMasterFailed=true;
		String lastId = mLastMasterId != null ? mLastMasterId : mSettingsExts.getMaster();
		mSettingsExts.speak(R.string.unbind_failed, 0);
		mLastMasterId = null;
		mSettingsExts.reportUnbindMaster(lastId, false);
	}
	
	public void doRelogin(){
		loginFailureNum++;
		if (loginFailureNum > 3) {
			loginFailureNum = 0;
			Log.i(TAG, "login retry more than 3 times");
			mSettingsExts.playAudio(SettingsExts.NETWORKUNAVA);
			mHandler.post(new Runnable() {
				@Override
				public void run() {
					try {
						Thread.sleep(2000);
					} catch (Exception e) {
						e.printStackTrace();
					}
					mHandler.sendEmptyMessage(MESSAGE_GO_SCAN_CODE);
				}
			});
		} else {
			if(mAccountManager!=null)
				mSettingsExts.doLogin(mAccountManager);
		}
	}

	private void waitting() {
		connectedLock.lock();
		try {
			connectedCondition.await();
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			connectedLock.unlock();
		}
	}

	private class WifiManagerCallback implements IRKWifiManagerCallback {
		@Override
		public void connected(boolean recovery) {
			Log.i(TAG, "WifiManagerCallback  wifi connected!");
			
		}

		@Override
		public void disconnected() {
			Log.i(TAG, "WifiManagerCallback  wifi disconnected!");
		}

		@Override
		public void passwdError() {
			Log.i(TAG, "WifiManagerCallback  wifi passwdError!");
			mSettingsExts.playAudio(SettingsExts.PWD_ERROR);
			try{
				Thread.sleep(4000);
			}catch (Exception e) {
				e.printStackTrace();
			}
			mWifiManager.disconnect(true);
			mHandler.obtainMessage(MESSAGE_SEND_EVENT_TO_FAKE_QR, "connectFail").sendToTarget();
		}

		@Override
		public void ssidNotFind() {
			
		}
	}
	
	public void setBindMasterState(boolean state){
		bindMasterFailed=state;
	}
	
	public boolean getBindMasterState(){
		return bindMasterFailed;
	}
	
	@Override
	public void onDestroy() {
		super.onDestroy();
		unregisterCallback();
	}
}
