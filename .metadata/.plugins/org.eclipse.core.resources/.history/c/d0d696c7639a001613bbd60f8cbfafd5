package com.rokid.wifi;

import rokid.os.RKWifiManagerNativeStub;
import rokid.os.IRKWifiManagerCallback;
import com.rokid.wifi.WifiEventReceiver.WifiEventCallback;
import android.content.Context;
import android.os.Handler;
import android.os.Looper;
import android.os.IBinder;
import android.os.Message;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiConfiguration.KeyMgmt;
import android.net.wifi.WifiConfiguration.AuthAlgorithm;
import android.net.wifi.WifiInfo;
import android.net.wifi.SupplicantState;
import android.net.wifi.ScanResult;
import android.net.NetworkInfo;
import android.net.NetworkInfo.DetailedState;
import java.util.concurrent.atomic.AtomicBoolean;
import android.util.Log;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Collections;

public class RKWifiManagerNative extends RKWifiManagerNativeStub implements WifiEventCallback{

	private final String TAG = "RKWifiManagerNative";
	private final String UNKNOWN_SSID="<unknown ssid>";
	private final String _0x0="0x0";//default ssid
	
	private final int MESSAGE_WIFI_CONNECT_TIMEOUT=0;
	public static final int MESSAGE_START_SCAN=1;
	private final int MESSAGE_PASSWORD_ERROR=2; 
	private final int MESSAGE_WIFI_DISCONNECT=3;

	private static final String WIFI_STATE_CONNECTED="CONNECTED";
	private static final String WIFI_STATE_DISCONNECTED="DISCONNECTED";
	private static final String WIFI_STATE_OBTAINING_IPADDR="OBTAINING_IPADDR";
	private static final String WIFI_STATE_VERIFYING_POOR_LINK="VERIFYING_POOR_LINK";
	private static final String WIFI_STATE_CAPTIVE_PORTAL_CHECK="CAPTIVE_PORTAL_CHECK";

	private Context mContext;
	private WifiManager mWifiManager;
	private WifiEventReceiver mWifiEventReceiver;
	private RKWifiNotifier mRKWifiNotifier;
	private RKWifiScanner mRKWifiScanner;
	private DetailedState mDetailedState;
	private WifiInfo mWifiInfo;
	private AccessPoint mConnectingAP;
	private WifiConfiguration mCurrentWifiConfiguration;
	private static String mConnectingState=WIFI_STATE_DISCONNECTED;

	private Multimap<String, AccessPoint> apMap=new Multimap<String,AccessPoint>();
	private List<AccessPoint> mAccessPointList=new ArrayList<AccessPoint>();
	private	AtomicBoolean mConnectState = new AtomicBoolean(false); 


	private Handler mHandler =new Handler(){
		public void handleMessage(Message msg){
			switch(msg.what){
				case MESSAGE_WIFI_CONNECT_TIMEOUT:
					onDisconnect();
					Log.e(TAG,"MESSAGE_WIFI_CONNECT_TIMEOUT");
					mRKWifiNotifier.notifyDisconnected();
					break;
				case MESSAGE_START_SCAN:
					mRKWifiScanner.startScann();
					break;
				case MESSAGE_PASSWORD_ERROR:
					forget();
					mRKWifiNotifier.notifyPasswdError();
					break;
				case MESSAGE_WIFI_DISCONNECT:

					break;
			}
		}
	};

	public RKWifiManagerNative(Context mContext){
		this.mContext=mContext;
		mConnectState.set(false);
	}
	@Override
	public void handleStartInit(){
		mWifiManager = (WifiManager)mContext.getSystemService(Context.WIFI_SERVICE);
		if(!mWifiManager.isWifiEnabled()){
			mWifiManager.setWifiEnabled(true);
		}
		mRKWifiScanner = RKWifiScanner.getInstance(mWifiManager);
		mRKWifiScanner.setMessageHandler(mHandler);
		mRKWifiNotifier=new RKWifiNotifier();
		mWifiEventReceiver=new WifiEventReceiver(mContext,this);
		mWifiEventReceiver.register();
	}
	@Override
	public boolean isWifiConnected(){
		return mConnectState.get();
	}
	@Override
	public void onWifiStateChanged(int state){
		if(WifiManager.WIFI_STATE_ENABLED==state){
			mRKWifiScanner.startScann();
		}else{
			mRKWifiScanner.stopScann();
		}
	}
	@Override
	public synchronized void onUpdateAccessPoints(){
		if(WifiManager.WIFI_STATE_ENABLED==mWifiManager.getWifiState()){
			createAccessPoints(); 
		}else{
			mAccessPointList.clear();
			apMap.clear();
		}
	}
    public void createAccessPoints() {
		final List<WifiConfiguration> configs = mWifiManager.getConfiguredNetworks();
//		if (configs != null) {
//			for (WifiConfiguration config : configs) {
//				AccessPoint ap = new AccessPoint(config);
//				ap.update(mDetailedState, mWifiInfo);
//				mAccessPointList.add(ap);
//				apMap.put(ap.ssid, ap);
//			}
//		}

		final List<ScanResult> results = mWifiManager.getScanResults();
		if (results != null) {
			for (ScanResult result : results) {
				if (result.SSID == null || result.SSID.length() == 0 
						|| result.capabilities.contains("[IBSS]")) {
					continue;
				}

				boolean found = false;
				for (AccessPoint mAccessPoint : apMap.getAll(result.SSID)) {
					if (mAccessPoint.update(result))
						found = true;
				}

				if (!found) {
					AccessPoint mAccessPoint = new AccessPoint(result);
					mAccessPointList.add(mAccessPoint);
					apMap.put(mAccessPoint.ssid, mAccessPoint);
				}
			}
		}
		Collections.sort(mAccessPointList); 
	}
	@Override
	public boolean connect(String ssid,String pwd){
		List<WifiConfiguration> list = mWifiManager.getConfiguredNetworks();	
		for (WifiConfiguration wifi : list) {
			mWifiManager.removeNetwork(wifi.networkId);
		}
		Log.i(TAG, "TRY " + ssid + " with pwd " + pwd);
		if (ssid == null || "".equals(ssid) || pwd == null || "".equals(pwd)) {
			Log.e(TAG, "read empty ssid or pwd!");
			return false;
		}
		List<AccessPoint> ssids = null;
		if ((ssids = apMap.getAll(ssid)) == null || ssids.isEmpty()) {
			Log.e(TAG, "cannot find such ssid");
			return false;
		}
		AccessPoint ap = null;
		for (int i = 0; i < ssids.size(); i++) {
			ap = ssids.get(i);
			if (ap == null) {
				continue;
			}
			if (ap != null) {
				break;
			}
		}
		//get config from ap
		final WifiConfiguration configure = new WifiConfiguration();
		if (ap.networkId == -1) {
			Log.i(TAG, "ap network is -1");
			configure.SSID = AccessPoint.convertToQuotedString(ap.ssid);
		} else {
			Log.i(TAG, "ap network is " + ap.networkId);
			configure.networkId = ap.networkId;
		}

		switch (ap.security) {
		case AccessPoint.SECURITY_NONE: {
			configure.allowedKeyManagement.set(KeyMgmt.NONE);
		} break;
		//ignore
		case AccessPoint.SECURITY_WEP: {
			configure.allowedKeyManagement.set(KeyMgmt.NONE);
			configure.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
			configure.allowedAuthAlgorithms.set(AuthAlgorithm.SHARED);
			int len = pwd.length();
			if ((len == 10) || (len == 26) || (len == 58) &&
					pwd.matches("[0-9A-Fa-f]*")) {
				configure.wepKeys[0] = pwd;
			} else {
				configure.wepKeys[0] = '"' + pwd + '"';
			}
			configure.wepKeys[0] = pwd;
		} break;
		case AccessPoint.SECURITY_PSK: {
			configure.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
			if (pwd.matches("[0-9A-Fa-f]{64}")) {
				configure.preSharedKey = pwd;
			} else {
				configure.preSharedKey = '"' + pwd + '"';
			}
		} break;
		case AccessPoint.SECURITY_EAP: {
			Log.e(TAG, "not support EAP yet");
			return false;
		}
		default:
			Log.e(TAG, "WTF UNKNOWN SECURITY");
			return false;
		}

		//connect
		if (configure.networkId != -1) {
			mWifiManager.save(configure, new WifiManager.ActionListener() {
                @Override
                public void onSuccess() {
                }
                @Override
                public void onFailure(int reason) {
					Log.e(TAG,"save fail ...");
                }
            });
		}

		//direct connect
		mWifiManager.connect(configure, new WifiManager.ActionListener() {
           @Override
           public void onSuccess() {
				Log.i(TAG, "connect successfully!");
           }
           @Override
           public void onFailure(int reason) {
			   Log.e(TAG,"connect fail ...");
           }
		});


		if (mWifiManager.isWifiEnabled()) {
			mRKWifiScanner.startScann();
		}

		ap.mConfig = configure;
		mConnectingAP = ap;
		onUpdateAccessPoints();

		mHandler.removeMessages(MESSAGE_WIFI_CONNECT_TIMEOUT);
		mHandler.sendEmptyMessageDelayed(MESSAGE_PASSWORD_ERROR,10000);
		Log.i(TAG, "start timeout ...");
		mHandler.sendEmptyMessageDelayed(MESSAGE_WIFI_CONNECT_TIMEOUT, 60000);
		return true;
	}
	@Override
	public void onSupplicantConnectionStateChanged(SupplicantState state,int error){
		WifiInfo mWifiInfo=mWifiManager.getConnectionInfo();
		Log.e(TAG,error+"   >>>   "+state.name()+"   >>>   "+mWifiInfo.getSSID());
		if(error==WifiManager.ERROR_AUTHENTICATING){
			if(!mHandler.hasMessages(MESSAGE_PASSWORD_ERROR)){
				mHandler.sendEmptyMessage(MESSAGE_PASSWORD_ERROR);	
			}	
		}
		switch(state){
			case DISCONNECTED:
				mConnectingState=state.name();
				mConnectState.set(false);
				if(mWifiManager.isWifiEnabled()){
					mRKWifiScanner.startScann();
				}
				if(error==WifiManager.ERROR_AUTHENTICATING){
					mHandler.removeMessages(MESSAGE_PASSWORD_ERROR);
					mHandler.removeMessages(MESSAGE_WIFI_CONNECT_TIMEOUT);
					mHandler.sendEmptyMessage(MESSAGE_PASSWORD_ERROR);	
				}else{
					mRKWifiNotifier.notifyDisconnected();
				}
				break;
			case COMPLETED:
				break;
		}
	}
	@Override
	public void onUpdateNetworkChanged(NetworkInfo info,WifiInfo mWifiInfo) {
		DetailedState mDetailedState=info.getDetailedState();
		Log.e(TAG, mDetailedState.name()+"  >>  "+info.getExtraInfo()+"  >>  "+info.isConnectedOrConnecting());
	
		mHandler.removeMessages(MESSAGE_WIFI_CONNECT_TIMEOUT);
		switch(mDetailedState){
			case OBTAINING_IPADDR:
				mConnectingState=mDetailedState.name();
				mRKWifiScanner.stopScann();
				mHandler.removeMessages(MESSAGE_PASSWORD_ERROR);
				break;
			case VERIFYING_POOR_LINK:
				mConnectingState=mDetailedState.name();
				break;
			case CAPTIVE_PORTAL_CHECK:
				mConnectingState=mDetailedState.name();
				break;
			case CONNECTED:
				mConnectingState=mDetailedState.name();
				mConnectState.set(true);
				onNetworkConnected();
				break;
			case DISCONNECTED:
			default:
				if(mConnectingAP==null){
					mConnectState.set(false);
					if(mWifiManager.isWifiEnabled()){
						mRKWifiScanner.startScann();
					}
					mRKWifiNotifier.notifyDisconnected();
				}else{
					Log.e(TAG,"... ...");
				}
				break;
		}
	}

	private class Multimap<K, V> {
		private final HashMap<K, List<V>> store = new HashMap<K, List<V>>();
		List<V> getAll(K key) {
			List<V> values = store.get(key);
			return values != null ? values : Collections.<V>emptyList();
		}

		void clear() {
			store.clear();
		}

		void put(K key, V val) {
			List<V> valList = store.get(key);
			if (valList == null) {
				valList = new ArrayList<V>(3);
				store.put(key, valList);
			}
			valList.add(val);
		}

		HashMap<K, List<V>> getInternal() {
			return store;
		}
	}

	public void onNetworkConnected(){
		mHandler.removeMessages(MESSAGE_PASSWORD_ERROR);
		mHandler.removeMessages(MESSAGE_WIFI_CONNECT_TIMEOUT);
		mRKWifiNotifier.notifyConnected(true); 	
	}
	@Override
	public void setWifiStatusListener(IRKWifiManagerCallback cb) {
		mRKWifiNotifier.register(cb);
	}
	@Override
	public void removeWifiStatusListener(IRKWifiManagerCallback cb) {
		mRKWifiNotifier.unregister(cb);
	}
	@Override
	public void disconnect(boolean forget) {
		if (forget) {
			List<WifiConfiguration> list = mWifiManager.getConfiguredNetworks();
			for (WifiConfiguration wifi : list) {
				mWifiManager.removeNetwork(wifi.networkId);
			}
			mWifiManager.saveConfiguration();
			
		}
		// TODO: why comment ?
		// wifiManager.disconnect();
	}

	public void onDisconnect(){
		forget();
		mRKWifiNotifier.notifyDisconnected();
	}

	public void forget(){
		if(mConnectingAP!=null){
			WifiConfiguration config = mConnectingAP.getConfig();
			for(WifiConfiguration configuration:mWifiManager.getConfiguredNetworks()){
				if(config.SSID.equals(configuration.SSID)){
					
					mWifiManager.forget(configuration.networkId, new WifiManager.ActionListener() {
						@Override
						public void onSuccess() {
						}
						@Override
						public void onFailure(int reason) {
							Log.e (TAG, "forget failed...");
						}
					});
				}
			}
		}
		mConnectState.set(false);
		mRKWifiScanner.startScann();
		mConnectingAP=null;
		mHandler.removeMessages(MESSAGE_PASSWORD_ERROR);
		mHandler.removeMessages(MESSAGE_WIFI_CONNECT_TIMEOUT);
	}
	@Override
	public void onUpdateConnectionState(DetailedState state){
		Log.e(TAG,"onUpdateConnectionState");
	}
	@Override
	public void handleWifiCheck(IBinder incubator){

	}
	@Override
	public boolean isWifiConnecting(){
		if(mConnectingState.equals(WIFI_STATE_OBTAINING_IPADDR)
				||mConnectingState.equals(WIFI_STATE_VERIFYING_POOR_LINK)
				||mConnectingState.equals(WIFI_STATE_CAPTIVE_PORTAL_CHECK)){
			return true;
		}
		return false;	
	}
}
