package com.rokid.wifi;

import rokid.os.RKWifiManagerNativeStub;
import rokid.os.IRKWifiManagerCallback;
import com.rokid.wifi.WifiEventReceiver.WifiEventCallback;
import android.content.Context;
import android.os.Handler;
import android.os.Looper;
import android.os.IBinder;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiConfiguration.KeyMgmt;
import android.net.wifi.WifiConfiguration.AuthAlgorithm;
import android.net.wifi.WifiInfo;
import android.net.wifi.SupplicantState;
import android.net.wifi.ScanResult;
import android.net.NetworkInfo;
import android.net.NetworkInfo.DetailedState;
import java.util.concurrent.atomic.AtomicBoolean;
import android.util.Log;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Collections;

public class RKWifiManagerNative extends RKWifiManagerNativeStub implements WifiEventCallback {

	private final String TAG = "RKWifiManagerNative";
	private final String UNKNOWN_SSID="<unknown ssid>";
	private final String _0x0="0x0";//default ssid

	private Context serviceContext;
	private WifiManager mWifiManager;
	private WifiEventReceiver wifiEventReceiver;
	private RKWifiMessageHandler messageHandler;
	private APScanner apScanner;
	private RKWifiNotifier wifiNotifier;
	private AtomicBoolean wifiConnected;
	private ArrayList<AccessPoint> accessPoints;
	private Multimap<String, AccessPoint> apMap;
	private AccessPoint connectingAccessPoint;
	private DetailedState lastState;
	private WifiInfo lastInfo;
	private DetailedState mConnectingState;

	private static final int WIFI_STATE_DISCONNECTED=0;
	private static final int WIFI_STATE_OBTAINING_IPADDR=1;
	private static final int WIFI_STATE_VERIFYING_POOR_LINK=2;
	private static final int WIFI_STATE_CAPTIVE_PORTAL_CHECK=3;
	private static final int WIFI_STATE_CONNECTED=4;
	private static int mConnectState=WIFI_STATE_DISCONNECTED;
//	private static int mConnectingState=WIFI_STATE_DISCONNECTED;
	/*
	 * ap is set but connection is not ok
	 * */
	private int lastConnectedState = WIFI_STATE_DISCONNECTED;

	public RKWifiManagerNative(Context context) {
		serviceContext = context;
		wifiConnected = new AtomicBoolean(false);
	}

	// *********************************
	// * methods that called by binder *
	// *********************************
	protected void handleStartInit() {
		mWifiManager= (WifiManager)serviceContext.getSystemService(Context.WIFI_SERVICE);
		if (!wifiManager.isWifiEnabled())
			wifiManager.setWifiEnabled(true);

		apScanner = APScanner.getInstance(wifiManager);
		messageHandler = new RKWifiMessageHandler(Looper.getMainLooper(), apScanner, this);
		apScanner.setMessageHandler(messageHandler);
		wifiNotifier = new RKWifiNotifier();

		wifiEventReceiver = new WifiEventReceiver(serviceContext, this);
		wifiEventReceiver.register();
		
	}

	protected void handleWifiCheck(IBinder incubator) {
		// no use ?
		// empty implementation
		
	}

	public boolean isWifiConnecting(){
		if(mConnectingState==WIFI_STATE_OBTAINING_IPADDR
				||mConnectingState==WIFI_STATE_VERIFYING_POOR_LINK
				||mConnectingState==WIFI_STATE_CAPTIVE_PORTAL_CHECK){
			return true;
		}
		return false;
	}

	public boolean isWifiConnected() {
		return wifiConnected.get();
	}

	public boolean connect(String ssid, String pwd) {
		//clear configuration
		List<WifiConfiguration> list = mWifiManager.getConfiguredNetworks();
		for (WifiConfiguration wifi : list) {
			wifiManager.removeNetwork(wifi.networkId);
		}

		Log.i(TAG, "TRY " + ssid + " with pwd " + pwd);
		if (ssid == null || "".equals(ssid)|| pwd == null || "".equals(pwd)) {
			Log.e(TAG, "read empty ssid or pwd!");
			return false;
		}

		List<AccessPoint> ssids = null;
		if ((ssids = apMap.getAll(ssid)) == null || ssids.isEmpty()) {
			Log.e(TAG, "cannot find such ssid");
			return false;
		}

		//if ssid is ok
		//connect it
		//connect the first one
		AccessPoint ap = null;
		for (int i = 0; i < ssids.size(); i++) {
			ap = ssids.get(i);
			if (ap == null) {
				Log.e(TAG, "null ap");
				continue;
			}
			if (ap != null) {
				break;
			}
		}

		//get config from ap
		final WifiConfiguration configure = new WifiConfiguration();
		if (ap.networkId == -1) {
			Log.i(TAG, "ap network is -1");
			configure.SSID = AccessPoint.convertToQuotedString(ap.ssid);
		} else {
			Log.i(TAG, "ap network is " + ap.networkId);
			configure.networkId = ap.networkId;
		}

		switch (ap.security) {
		case AccessPoint.SECURITY_NONE: {
			configure.allowedKeyManagement.set(KeyMgmt.NONE);
		} break;
		//ignore
		case AccessPoint.SECURITY_WEP: {
			configure.allowedKeyManagement.set(KeyMgmt.NONE);
			configure.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
			configure.allowedAuthAlgorithms.set(AuthAlgorithm.SHARED);
			int len = pwd.length();
			if ((len == 10) || (len == 26) || (len == 58) &&
					pwd.matches("[0-9A-Fa-f]*")) {
				configure.wepKeys[0] = pwd;
			} else {
				configure.wepKeys[0] = '"' + pwd + '"';
			}
			configure.wepKeys[0] = pwd;
		} break;
		case AccessPoint.SECURITY_PSK: {
			configure.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
			if (pwd.matches("[0-9A-Fa-f]{64}")) {
				configure.preSharedKey = pwd;
			} else {
				configure.preSharedKey = '"' + pwd + '"';
			}
		} break;
		case AccessPoint.SECURITY_EAP: {
			Log.e(TAG, "not support EAP yet");
			return false;
		}
		default:
			Log.e(TAG, "WTF UNKNOWN SECURITY");
			return false;
		}

		//connect
		if (configure.networkId != -1) {
			//save first
			mWifiManager.save(configure, new mWifiManager.ActionListener() {
                @Override
                public void onSuccess() {
                }
                @Override
                public void onFailure(int reason) {
                	onSaveConfigureFailed(reason);
                }
            });
		}

		//direct connect
		mWifiManager.connect(configure, new mWifiManager.ActionListener() {
           @Override
           public void onSuccess() {
				Log.i(TAG, "connect successfully!");
           }
           @Override
           public void onFailure(int reason) {
               onConnectionFailed(reason);
           }
		});


		if (mWifiManager.isWifiEnabled()) {
			apScanner.resume();
		}

		// setup connecting ap, wait for it becomes CURRENT
		ap.mConfig = configure;
		connectingAccessPoint = ap;
		onUpdateAccessPoints();

		messageHandler.removeMessages(RKWifiMessageHandler.MESSAGE_WIFI_CONNECT_TIMEOUT);
		Log.i(TAG, "start timeout timer");
		messageHandler.sendEmptyMessageDelayed(RKWifiMessageHandler.MESSAGE_WIFI_CONNECT_TIMEOUT, 60000);
		return true;
	}

	public void disconnect(boolean forget) {
		if (forget) {
			List<WifiConfiguration> list = mWifiManager.getConfiguredNetworks();
			for (WifiConfiguration wifi : list) {
				mWifiManager.removeNetwork(wifi.networkId);
			}
			// save the modify
			mWifiManager.saveConfiguration();
		}
		// TODO: why comment ?
		// wifiManager.disconnect();
	}

	public void setWifiStatusListener(IRKWifiManagerCallback cb) {
		wifiNotifier.register(cb);
	}

	public void removeWifiStatusListener(IRKWifiManagerCallback cb) {
		wifiNotifier.unregister(cb);
	}


	// *************************************************
	// * implementation of interface WifiEventCallback *
	// *************************************************
	public void onWifiStateChanged(int state) {
		switch (state) {
		case mWifiManager.WIFI_STATE_ENABLED:
			new Handler().sendEmptyMessage(what);
			return;
		case mWifiManager.WIFI_STATE_ENABLING:
			//show we are enabling...
			break;
		case mWifiManager.WIFI_STATE_DISABLED:
		default:
			//clean up
			lastState = null;
			lastInfo = null;
			apScanner.pause();
			break;
		}
	}

	public synchronized void onUpdateAccessPoints() {
		final int wifiState = mWifiManager.getWifiState();

		switch (wifiState) {
		case mWifiManager.WIFI_STATE_ENABLED:
			createAccessPoints();
			break;
		case mWifiManager.WIFI_STATE_ENABLING:
		case mWifiManager.WIFI_STATE_DISABLING:
		case mWifiManager.WIFI_STATE_DISABLED:
		default:
			accessPoints.clear();
			apMap.clear();
			break;
		}
	}

	public void onUpdateConnectionState(DetailedState state) {
		updateConnectionState(state);
	}

	public void onUpdateNetworkChanged(NetworkInfo info) {

		DetailedState mDetailedState=info.getDetailedState();
		Log.e(TAG, mDetailedState.name()+"  >>  "+info.getExtraInfo()+"  >>  "+info.isConnectedOrConnecting());
		if(!UNKNOWN_SSID.equals(info.getExtraInfo())){
			messageHandler.removeMessages(RKWifiMessageHandler.MESSAGE_WIFI_CONNECT_TIMEOUT);
			if(mConnectingState<checkConnectingState(mDetailedState)){
				mConnectState=mDetailedState.name();
			}
		}

		wifiConnected.set(info.isConnected());
		//if connected or disconnected should report
		//is connected
		if (wifiConnected.get()) {
			Log.i(TAG, "network connected!");
			onNetworkConnected();
		}else if(DISCONNECTED.equals(mDetailedState.name())){
			messageHandler.sendEmptyMessage(RKWifiMessageHandler.MESSAGE_WIFI_CONNECT_TIMEOUT);
		}
	}

	private synchronized void onNetworkConnected() {
		boolean recovery = false;
		messageHandler.removeMessages(RKWifiMessageHandler.MESSAGE_WIFI_CONNECT_TIMEOUT);

		if (connectingAccessPoint != null) {
			recovery = false;
		} else {
			recovery = true;
		}
		//clear connecting ap
		connectingAccessPoint = null;
		//From CONN TO CONN ? WTF
		if (lastConnectedState == WIFI_STATE_CONNECTED) {
			Log.w(TAG, "from connect to connect ...");
		}

		//stop scanning
		apScanner.pause();
		//we are connected
		lastConnectedState = WIFI_STATE_CONNECTED;
		//maybe recovery, maybe pair successfully
		wifiNotifier.notifyConnected(recovery);
	}

	public void onSupplicantConnectionStateChanged(SupplicantState state,int error) {
		WifiInfo mWifiInfo=mWifiManager.getConnectionInfo();
		if(error==1&&_0x0.equals(mWifiInfo.getSSID())){
		}
		if (!wifiConnected.get() && WifiEventReceiver.isHandshakeState(state)) {
			updateConnectionState(WifiInfo.getDetailedStateOf(state));
		} else {
			updateConnectionState(null);
		}
	}

	// ********************
	// * message handlers *
	// ********************
	public void onDisconnect() {
		//disconnect with pairing failed..
		if (connectingAccessPoint != null) {
			//wtf mConnected become true....
			if (wifiConnected.get()) {
				Log.e(TAG, "wtf disconnect with connection done...");
				connectingAccessPoint = null;
				return;
			}

			WifiConfiguration config = connectingAccessPoint.getConfig();
			for (WifiConfiguration configuration: mWifiManager.getConfiguredNetworks()) {
				//forget the error one
				if (configuration.SSID.equals(config.SSID)) {
					Log.w(TAG, "forget current ap...pwd may be wrong");
					mWifiManager.forget(configuration.networkId, new mWifiManager.ActionListener() {
						@Override
						public void onSuccess() {
						}
						@Override
						public void onFailure(int reason) {
							Log.e (TAG, "forget failed...");
						}
					});
				}
			}
			Log.e(TAG, "connect failed since AUTH timeout! ");
			lastConnectedState = WIFI_STATE_DISCONNECTED;
			connectingAccessPoint = null;
			//onConnectFailed...
			//tell the client...
			messageHandler.removeMessages(RKWifiMessageHandler.MESSAGE_WIFI_CONNECT_TIMEOUT);
			wifiNotifier.notifyPasswdError();
			return;
		}
		//disconnect from the connect state?
		Log.i(TAG, "recv message disconnect without connectingAP...");
		messageHandler.removeMessages(RKWifiMessageHandler.MESSAGE_WIFI_CONNECT_TIMEOUT);
		onNetworkReallyDisconnected();
	}

	public void onConnectTimeout() {
		Log.e(TAG, "connection timeout");
		synchronized (this) {
			//we are in a pairing progress
			if (connectingAccessPoint != null) {
				if (wifiConnected.get()) {
					Log.i(TAG, "timeout with connected");
					connectingAccessPoint = null;
					lastConnectedState = WIFI_STATE_CONNECTED;
					wifiNotifier.notifyConnected(false);
				} else {
					connectingAccessPoint = null;
					lastConnectedState = WIFI_STATE_DISCONNECTED;
					wifiNotifier.notifyPasswdError();
				}
			//we are in a disconnect progress
			} else {
				if (wifiConnected.get()) {
					Log.i(TAG, "timeout with connected");
					lastConnectedState = WIFI_STATE_CONNECTED;
					wifiNotifier.notifyConnected(true);
				} else {
					lastConnectedState = WIFI_STATE_DISCONNECTED;
					wifiNotifier.notifyDisconnected();
				}
			}
		}
	}

    private void createAccessPoints() {
		accessPoints = new ArrayList<AccessPoint>();
		apMap = new Multimap<String, AccessPoint>();
		final List<WifiConfiguration> configs = mWifiManager.getConfiguredNetworks();
		if (configs != null) {
			for (WifiConfiguration conf : configs) {
				AccessPoint ap = new AccessPoint(conf);
				ap.update(lastInfo, lastState);
				accessPoints.add(ap);
				apMap.put(ap.ssid, ap);
			}
		}

		final List<ScanResult> results = mWifiManager.getScanResults();
		if (results != null) {
			for (ScanResult result : results) {
				if (result.SSID == null || result.SSID.length() == 0 ||
						result.capabilities.contains("[IBSS]")) {
					continue;
				}

				boolean found = false;
				for (AccessPoint accessPoint : apMap.getAll(result.SSID)) {
					if (accessPoint.update(result))
						found = true;
				}

				if (!found) {
					AccessPoint accessPoint = new AccessPoint(result);
					accessPoints.add(accessPoint);
					apMap.put(accessPoint.ssid, accessPoint);
				}
			}
		}
		Collections.sort(accessPoints);
    }

	private void updateConnectionState(DetailedState state) {
		if (!mWifiManager.isWifiEnabled()) {
			apScanner.pause();
			return;
		}

		if (state == DetailedState.OBTAINING_IPADDR) {
			apScanner.pause();
		} else {
			apScanner.resume();
		}

		lastInfo = mWifiManager.getConnectionInfo();
		if (state != null) {
			lastState = state;
		}

		for (AccessPoint accessPoint: accessPoints) {
			accessPoint.update(lastInfo, lastState);
		}
	}

	private void onNetworkReallyDisconnected() {
		Log.i(TAG, "really disconnect...");
		lastConnectedState = WIFI_STATE_DISCONNECTED;
		connectingAccessPoint = null;

		messageHandler.removeMessages(RKWifiMessageHandler.MESSAGE_WIFI_CONNECT_TIMEOUT);
		//notify client
		wifiNotifier.notifyDisconnected();
	}

	private void onSaveConfigureFailed(int reason) {
		Log.e(TAG, "save failed for " + reason);
	}

	private void onConnectionFailed(int reason) {
		Log.e(TAG, "connect failed for " + reason);
	}

	// ******************
	// * internal class *
	// ******************
	private class Multimap<K, V> {
		private final HashMap<K, List<V>> store = new HashMap<K, List<V>>();
		List<V> getAll(K key) {
			List<V> values = store.get(key);
			return values != null ? values : Collections.<V>emptyList();
		}

		void clear() {
			store.clear();
		}

		void put(K key, V val) {
			List<V> valList = store.get(key);
			if (valList == null) {
				valList = new ArrayList<V>(3);
				store.put(key, valList);
			}
			valList.add(val);
		}

		HashMap<K, List<V>> getInternal() {
			return store;
		}
	}

	private int checkConnectingState(DetailedState state){
		if(DetailedState.OBTAINING_IPADDR==state){
			return WIFI_STATE_OBTAINING_IPADDR;
		}else if(DetailedState.VERIFYING_POOR_LINK==state){
			return WIFI_STATE_VERIFYING_POOR_LINK;
		}else if(DetailedState.CAPTIVE_PORTAL_CHECK==state){
			return WIFI_STATE_CAPTIVE_PORTAL_CHECK;
		}else if(DetailedState.CONNECTED==state){
			return WIFI_STATE_CONNECTED;
		}else{
			return WIFI_STATE_DISCONNECTED;
		}
	}
}
