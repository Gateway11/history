package com.rokid.wifi.simple;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import org.json.JSONObject;
import rokid.os.ISiren;
import rokid.os.NativeSiren;
import android.R.integer;
import android.app.Instrumentation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.res.Configuration;
import android.media.MediaPlayer;
import android.net.NetworkInfo;
import android.net.Uri;
import android.net.NetworkInfo.DetailedState;
import android.net.wifi.ScanResult;
import android.net.wifi.SupplicantState;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiConfiguration.AuthAlgorithm;
import android.net.wifi.WifiConfiguration.KeyMgmt;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Message;
import android.os.Parcel;
import android.os.RemoteException;
import android.os.ServiceManager;
import android.util.Log;
import android.view.KeyEvent;

import com.google.android.collect.Maps;
import com.rokid.WifiMananger.R;
import com.rokid.wifi.AccessPoint;
import com.rokid.wifi.RKWifiManager;
import com.rokid.wifi.RKWifiManagerService;
import com.rokid.wifi.WifiEventReceiver.WifiEventCallback;

public class ShitSimpeWifiManager extends RKWifiManager implements WifiEventCallback{
	private static final String TAG = "ShitSimpleWifiManager";
	
	private AtomicBoolean mConnected = new AtomicBoolean(false);
	private ArrayList<AccessPoint> mAccessPoints = new ArrayList<AccessPoint>();
	//ssid <-> list<AccessPoint>
	private Multimap<String, AccessPoint> apMap = new Multimap<String, AccessPoint>();
	
	private DetailedState mLastState;
	private WifiInfo mLastInfo;
	//current connecting ap
	private AccessPoint mConnectingAccessPoint = null;
	
	/* 
	 * ap is set but connection is not ok
	 * */
	private int mLastConnectedState = WIFI_STATE_DISCONNECTED;
	private static final int WIFI_STATE_DISCONNECTED = 0;
	private static final int WIFI_STATE_CONNECTED = 1;
	
	
	public ShitSimpeWifiManager(RKWifiManagerService service, Context mContext) {
		super(service, mContext);
	}
	
	@Override
	public void handleWifiManagerInit() {
		Log.i(TAG, "handle wifi init");
		//default set wifi enabled
		if (!mWifiManager.isWifiEnabled()) {
			mWifiManager.setWifiEnabled(true);
		}

	}

	@Deprecated
	@Override
	public void handleWifiCheck() {
		Log.i(TAG, "handl wifi check");
		//writeShowUpdatesOption();
		
	}
	
	private void onSaveConfigureFailed(int reason) {
		Log.e(TAG, "save failed for " + reason);
	}
	
	private void onConnectionFailed(int reason) {
		Log.e(TAG, "connect failed for " + reason);
	}
	
    private String cachedMac;
    public String getWifiMac() {
        if (cachedMac == null) {
            File file = new File("/sys/class/net/wlan0/address");
            byte[] bs = new byte[128];
            String mac = null;
            if (file.exists()) {
                try {
                    FileInputStream fo = new FileInputStream(file);
                    fo.read(bs);
                    fo.close();
                    cachedMac = new String(bs, StandardCharsets.US_ASCII).trim();
                    return cachedMac;
                } catch (Exception e) {
                    e.printStackTrace();
                    cachedMac = "00:00:00:00:00:00";
                    return cachedMac;
                }
            } else {
                cachedMac = "00:00:00:00:00:00";
                return cachedMac;
            }
        } else {
            return cachedMac;
        }
    }
    
    private ArrayList<AccessPoint> createAccessPoints() {
    	synchronized (this) {
	    	final List<WifiConfiguration> configs = mWifiManager.getConfiguredNetworks();
	    	if (configs != null) {
	    		for (WifiConfiguration conf : configs) {
	    			AccessPoint ap = new AccessPoint(conf);
	    			ap.update(mLastInfo, mLastState);
	    			mAccessPoints.add(ap);
	    			apMap.put(ap.ssid, ap);
	    		}
	    	}
	    	
	    	final List<ScanResult> results = mWifiManager.getScanResults();
	    	if (results != null) {
	    		for (ScanResult result : results) {
	    			if (result.SSID == null || result.SSID.length() == 0 ||
	    					result.capabilities.contains("[IBSS]")) {
	    				continue;
	    			}
	    			
	    			boolean found = false;
	    			for (AccessPoint accessPoint : apMap.getAll(result.SSID)) {
	    				if (accessPoint.update(result)) 
	    					found = true;
	    			}
	    			
	    			if (!found) {
	    				AccessPoint accessPoint = new AccessPoint(result);
	    				mAccessPoints.add(accessPoint);
	    				apMap.put(accessPoint.ssid, accessPoint);
	    			}
	    		}
	    	}
	    	Collections.sort(mAccessPoints);
	    	return mAccessPoints;
    	}
    }

	@Override
	public void onWifiStateChanged(int state) {
		switch (state) {
		case WifiManager.WIFI_STATE_ENABLED:
			mScanner.resume();
			return;
		case WifiManager.WIFI_STATE_ENABLING: 
			//show we are enabling...
			
			break;
		case WifiManager.WIFI_STATE_DISABLED:
			//we are disabled!
			
			break;
		default:
			break;
		}
		
		//clean up
		mLastState = null;
		mLastInfo = null;
		
		mScanner.pause();
	}

	@Override
	public synchronized void onUpdateAccessPoints() {
		final int wifiState = mWifiManager.getWifiState();
		
		switch (wifiState) {
		case WifiManager.WIFI_STATE_ENABLED:
			mAccessPoints.clear();
			apMap.clear();
			mAccessPoints = createAccessPoints();
			break;
		case WifiManager.WIFI_STATE_ENABLING:
			mAccessPoints.clear();
			apMap.clear();
			break;
		case WifiManager.WIFI_STATE_DISABLING:
			mAccessPoints.clear();
			apMap.clear();
			break;
		case WifiManager.WIFI_STATE_DISABLED:
			mAccessPoints.clear();
			apMap.clear();
			break;
		default:
			break;
		}
	}

	@Override
	public void onUpdateConnectionState(DetailedState state) {
		updateConnectionState(state);
	}

	@Override
	public void onUpdateNetworkChanged(NetworkInfo info) {
		mConnected.set(info.isConnected());
		//if connected or disconnected should report
		//is connected
		if (mConnected.get()) {
			Log.i(TAG, "network connected!");
			onNetworkConnected();
		} else {
			Log.i(TAG, "network disconnected!");
			onNetworkDisconnected();
		}
	}
	
	private void onNetworkReallyDisconnected() {
		Log.i(TAG, "really disconnect...");
		mLastConnectedState = WIFI_STATE_DISCONNECTED;
		mConnectingAccessPoint = null;

		getHandler().removeMessages(MESSAGE_WIFI_CONNECT_TIMEOUT);
		//notify client
		performDisconnectNotify();
	}
	
	private void onNetworkDisconnected() {
		//FROM DIS -> DIS : PAIR ? TRUE DIS 
		if (!getHandler().hasMessages(MESSAGE_WIFI_DISCONNECT)) {
			//check 20s
			getHandler().sendEmptyMessageDelayed(MESSAGE_WIFI_DISCONNECT, 20000);
		} 
	}

	private synchronized void onNetworkConnected() {
		boolean recovery = false;
		getHandler().removeMessages(MESSAGE_WIFI_DISCONNECT);
		//remove timeout event
		getHandler().removeMessages(MESSAGE_WIFI_CONNECT_TIMEOUT);
		
		if (mConnectingAccessPoint != null) {
			recovery = false;
		} else {
			recovery = true;
		}
		//clear connecting ap
		mConnectingAccessPoint = null;
		//From CONN TO CONN ? WTF
		if (mLastConnectedState == WIFI_STATE_CONNECTED) {
			Log.w(TAG, "from connect to connect ...");
		}
		
		//stop scanning
		mScanner.pause();
		//we are connected
		mLastConnectedState = WIFI_STATE_CONNECTED;
		//maybe recovery, maybe pair successfully
		performConnectNotify(recovery);
	}

	private void updateConnectionState(DetailedState state) {
		if (!mWifiManager.isWifiEnabled()) {
			mScanner.pause();
			return;
		}
		
		if (state == DetailedState.OBTAINING_IPADDR) {
			mScanner.pause();
		} else {
			mScanner.resume();
		}
		
		mLastInfo = mWifiManager.getConnectionInfo();
		if (state != null) {
			mLastState = state;
		}
		
		for (AccessPoint accessPoint: mAccessPoints) {
			accessPoint.update(mLastInfo, mLastState);
		}
	}
	

	@Override
	public void onSupplicantConnectionStateChanged(SupplicantState state) {
		if (!mConnected.get() && RKWifiManager.isHandshakeState(state)) {
			updateConnectionState(WifiInfo.getDetailedStateOf(state));
		} else {
			updateConnectionState(null);
		}
	}
	
	private class Multimap<K, V> {
		private final HashMap<K, List<V>> store = new HashMap<K, List<V>>();
		List<V> getAll(K key) {
			List<V> values = store.get(key);
			return values != null ? values : Collections.<V>emptyList();
		}
		
		void clear() {
			store.clear();
		}
		
		void put(K key, V val) {
			List<V> valList = store.get(key);
			if (valList == null) {
				valList = new ArrayList<V>(3);
				store.put(key, valList);
			}
			valList.add(val);
		}
		
		HashMap<K, List<V>> getInternal() {
			return store;
		}
	}

	protected static final int MESSAGE_WIFI_DISCONNECT = 101;
	protected static final int MESSAGE_WIFI_CONNECT_TIMEOUT = 102;
	@Override
	public void hanldeWifiManagerEvent(Message message) {
		switch (message.what) {
		case MESSAGE_WIFI_DISCONNECT:
			//disconnect with pairing failed..
			if (mConnectingAccessPoint != null) {
				//wtf mConnected become true....
				if (mConnected.get()) {
					Log.e(TAG, "wtf disconnect with connection done...");
					mConnectingAccessPoint = null;
					return;
				} else {
					WifiConfiguration config = mConnectingAccessPoint.getConfig();
					for (WifiConfiguration configuration: mWifiManager.getConfiguredNetworks()) {
						//forget the error one
						if (configuration.SSID.equals(config.SSID)) { 
							Log.w(TAG, "forget current ap...pwd may be wrong");
							mWifiManager.forget(configuration.networkId, new WifiManager.ActionListener() {
				                @Override
				                public void onSuccess() {
				                }
				                @Override
				                public void onFailure(int reason) {
				                	Log.e (TAG, "forget failed...");
				                }
				            });
						}
					}
					Log.e(TAG, "connect failed since AUTH timeout! ");
					mLastConnectedState = WIFI_STATE_DISCONNECTED;
					mConnectingAccessPoint = null;
					//onConnectFailed...
					//tell the client...
					getHandler().removeMessages(MESSAGE_WIFI_CONNECT_TIMEOUT);
					performPasswdSSIDError();
					return;
				}
			//disconnect from the connect state?	
			} else {
				Log.i(TAG, "recv message disconnect without connectingAP...");
				getHandler().removeMessages(MESSAGE_WIFI_CONNECT_TIMEOUT);
				onNetworkReallyDisconnected();
			}
			break;
		case MESSAGE_WIFI_CONNECT_TIMEOUT:
			Log.e(TAG, "connection timeout");
			synchronized (this) {
				//we are in a pairing progress
				if (mConnectingAccessPoint != null) {
					if (mConnected.get()) {
						Log.i(TAG, "timeout with connected");
						mConnectingAccessPoint = null;
						mLastConnectedState = WIFI_STATE_CONNECTED;
						performConnectNotify(false);
						return;
					} else {
						mConnectingAccessPoint = null;
						mLastConnectedState = WIFI_STATE_DISCONNECTED;
						performPasswdSSIDError();
						return;
					}
				//we are in a disconnect progress	
				} else {
					if (mConnected.get()) {
						Log.i(TAG, "timeout with connected");
						mLastConnectedState = WIFI_STATE_CONNECTED;
						performConnectNotify(true);
						return;
					} else {
						mLastConnectedState = WIFI_STATE_DISCONNECTED;
						performDisconnectNotify();
						return;
					}
				}
			}
		default:
			break;
		}
	}
	
	private void writeShowUpdatesOption() {
		try {
			IBinder flinger = ServiceManager.getService("SurfaceFlinger");
			if (flinger != null) {
				Parcel data = Parcel.obtain();
				data.writeInterfaceToken("android.ui.ISurfaceComposer");
				data.writeInt(1);
				flinger.transact(1002, data, null, 0);
				data.recycle();
			}
		} catch (RemoteException ex) {
			ex.printStackTrace();
		}
	}
	
	private void performDisconnectNotify() {
		if (mProxy != null) {
			Parcel data = Parcel.obtain();
			try {
				data.writeInterfaceToken("com.rokid.RKWifiManager.RKWifiManagerClient");
				data.writeInt(0);
				mProxy.transact(IBinder.FIRST_CALL_TRANSACTION, data, null, IBinder.FIRST_CALL_TRANSACTION);
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				data.recycle();
			}
		}
	}
	
	private void performConnectNotify(boolean recovery) {
		if (mProxy != null) {
			Log.i(TAG, "perform connect notify");
			Parcel data = Parcel.obtain();
			try {
				data.writeInterfaceToken("com.rokid.RKWifiManager.RKWifiManagerClient");
				data.writeInt(1);
				data.writeInt(recovery ? 1 : 0);
				mProxy.transact(IBinder.FIRST_CALL_TRANSACTION, data, null, IBinder.FIRST_CALL_TRANSACTION);
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				data.recycle();
			}
		}
	}
	
	private void performPasswdSSIDError() {
		if (mProxy != null) {
			Parcel data = Parcel.obtain();
			try {
				data.writeInterfaceToken("com.rokid.RKWifiManager.RKWifiManagerClient");
				data.writeInt(2);
				mProxy.transact(IBinder.FIRST_CALL_TRANSACTION, data, null, IBinder.FIRST_CALL_TRANSACTION);
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				data.recycle();
			}
		}
	}
	
	private IBinder mProxy = null;
	public void setWifiChangeListener(IBinder proxy) {
		if (mProxy != null) {
			Log.w(TAG, "overwrite wifi change listener...");
		}
		
		this.mProxy = proxy;
	}

	public void disconnectWifi(boolean forget) {
		if (forget) {
			List<WifiConfiguration> list = mWifiManager.getConfiguredNetworks();
			for (WifiConfiguration wifi : list) {
				mWifiManager.removeNetwork(wifi.networkId);
			}
			// save the modify
			mWifiManager.saveConfiguration();
		}
		
		//mWifiManager.disconnect();
	}

	public synchronized boolean connectWifi(String ssid, String pwd) {
		//clear configuration
		List<WifiConfiguration> list = mWifiManager.getConfiguredNetworks();
		for (WifiConfiguration wifi : list) {
			mWifiManager.removeNetwork(wifi.networkId);
		}
		
		Log.i(TAG, "TRY " + ssid + " with pwd " + pwd);
		if (ssid == null || pwd == null) {
			Log.e(TAG, "read empty ssid or pwd!");
			return false;
		}
		
		//configure network
		//dump sys 
		for (Map.Entry<String, List<AccessPoint>> entry: apMap.getInternal().entrySet()) {
			Log.i (TAG, "entry start ssid: " + entry.getKey());
			for (AccessPoint ap : entry.getValue()) {
				Log.i(TAG, " bssid: " + ap.bssid);
			}
			Log.i(TAG, "entry end");
		}
		
		List<AccessPoint> ssids = null;
		if ((ssids = apMap.getAll(ssid)) == null || ssids.isEmpty()) {
			Log.e(TAG, "cannot find such ssid");
			return false;
		} 
		
		//if ssid is ok
		//connect it
		//connect the first one
		AccessPoint ap = null;
		for (int i = 0; i < ssids.size(); i++) {
			ap = ssids.get(i);
			if (ap == null) {
				Log.e(TAG, "null ap");
				continue;
			} 
			
			if (ap != null) {
				break;
			}
		}
		
		//get config from ap
		final WifiConfiguration configure = new WifiConfiguration();
		if (ap.networkId == -1) {
			Log.i(TAG, "ap network is -1");
			configure.SSID = AccessPoint.convertToQuotedString(ap.ssid);
		} else {
			Log.i(TAG, "ap network is " + ap.networkId);
			configure.networkId = ap.networkId;
		}
		
		switch (ap.security) {
		case AccessPoint.SECURITY_NONE: {
			configure.allowedKeyManagement.set(KeyMgmt.NONE);
		} break;
		//ignore
		case AccessPoint.SECURITY_WEP: {
			configure.allowedKeyManagement.set(KeyMgmt.NONE);
			configure.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
			configure.allowedAuthAlgorithms.set(AuthAlgorithm.SHARED);
			int len = pwd.length();
			if ((len == 10) || (len == 26) || (len == 58) && 
					pwd.matches("[0-9A-Fa-f]*")) {
				configure.wepKeys[0] = pwd;
			} else {
				configure.wepKeys[0] = '"' + pwd + '"';
			}
			configure.wepKeys[0] = pwd;
		} break;
		case AccessPoint.SECURITY_PSK: {
			configure.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
			if (pwd.matches("[0-9A-Fa-f]{64}")) {
				configure.preSharedKey = pwd;
			} else {
				configure.preSharedKey = '"' + pwd + '"';
			}
		} break;
		case AccessPoint.SECURITY_EAP: {
			Log.e(TAG, "not support EAP yet");
			return false;
		}
		default:
			Log.e(TAG, "WTF UNKNOWN SECURITY");
			return false;
		}
		
		//connect
		if (configure.networkId != -1) {
			//save first
			mWifiManager.save(configure, new WifiManager.ActionListener() {
                @Override
                public void onSuccess() {
                }
                @Override
                public void onFailure(int reason) {
                	onSaveConfigureFailed(reason);
                }
            });

		} 
		
		//direct connect
		mWifiManager.connect(configure, new WifiManager.ActionListener() {
           @Override
           public void onSuccess() {
				Log.i(TAG, "connect successfully!");
           }
           @Override
           public void onFailure(int reason) {
               onConnectionFailed(reason);
           }
       });
		
		
		if (mWifiManager.isWifiEnabled()) {
			mScanner.resume();
		}

		// setup connecting ap, wait for it becomes CURRENT
		ap.mConfig = configure;
		mConnectingAccessPoint = ap;
		onUpdateAccessPoints();

		// start timeout
		getHandler().removeMessages(MESSAGE_WIFI_CONNECT_TIMEOUT);
		getHandler().removeMessages(MESSAGE_WIFI_DISCONNECT);
		Log.i(TAG, "start timeout timer");
		getHandler().sendEmptyMessageDelayed(
				MESSAGE_WIFI_CONNECT_TIMEOUT, 120000);
		return true;
	}

	public boolean isWifiConnected() {
		return mConnected.get();
	}

	@Deprecated
	@Override
	public void handleWifiQRScanResult(String result) {
		// TODO Auto-generated method stub
		
	}
}
