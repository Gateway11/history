/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.os;

import java.util.ArrayList;




12-28 16:25:06.412: E/SELinux(1198): seapp_context_lookup:  No match for app with uid 1000, seinfo (null), name startup
12-28 16:25:06.413: E/SELinux(1198): selinux_android_setcontext:  Error setting context for app with uid 1000, seinfo (null): Success
12-28 16:25:06.414: E/Zygote(1198): selinux_android_setcontext(1000, 0, "(null)", "startup") failed
12-28 16:25:06.415: A/art(1198): art/runtime/jni_internal.cc:497] JNI FatalError called: RuntimeAbort
12-28 16:25:06.418: D/BluetoothService(643): onBootPhase: PHASE_SYSTEM_SERVICES_READY
12-28 16:25:06.424: I/WifiService(643): WifiService starting up with Wi-Fi enabled
12-28 16:25:06.427: D/WifiService(643): setWifiEnabled: true pid=643, uid=1000
12-28 16:25:06.428: E/WifiService(643): Invoking mWifiStateMachine.setWifiEnabled
12-28 16:25:06.431: D/WifiController(643): WifiController msg { when=-1ms what=155656 target=com.android.internal.util.StateMachine$SmHandler } deferred for 498ms
12-28 16:25:06.435: E/libbacktrace(1198): bool BacktraceCurrent::UnwindThread(size_t): tgkill 139 failed: No such process
12-28 16:25:06.451: E/libbacktrace(1198): bool BacktraceCurrent::UnwindThread(size_t): tgkill 139 failed: No such process
12-28 16:25:06.452: D/WifiService(643): New client listening to asynchronous messages
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366] Runtime aborting...
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366] Aborting thread:
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366] "main" prio=5 tid=1 Native
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   | group="" sCount=0 dsCount=0 obj=0x74551000 self=0xb4df6500
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   | sysTid=139 nice=0 cgrp=default sched=0/0 handle=0xb6fabb34
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   | state=? schedstat=( 0 0 0 ) utm=0 stm=0 core=0 HZ=100
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   | stack=0xbe1a4000-0xbe1a6000 stackSize=8MB
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   | held mutexes= "abort lock"
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   kernel: (couldn't read /proc/self/task/139/stack)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   native: (backtrace::Unwind failed for thread 139)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   at com.android.internal.os.Zygote.nativeForkAndSpecialize(Native method)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   at com.android.internal.os.Zygote.forkAndSpecialize(Zygote.java:93)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   at com.android.internal.os.ZygoteConnection.runOnce(ZygoteConnection.java:225)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   at com.android.internal.os.ZygoteInit.runSelectLoop(ZygoteInit.java:706)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366] Dumping all threads without appropriate locks held: thread list lock mutator lock
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366] All threads:
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366] DALVIK THREADS (1):
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366] "main" prio=5 tid=1 Runnable
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   | group="" sCount=0 dsCount=0 obj=0x74551000 self=0xb4df6500
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   | sysTid=139 nice=0 cgrp=default sched=0/0 handle=0xb6fabb34
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   | state=? schedstat=( 0 0 0 ) utm=0 stm=0 core=0 HZ=100
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   | stack=0xbe1a4000-0xbe1a6000 stackSize=8MB
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   | held mutexes= "abort lock" "mutator lock"(shared held)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   kernel: (couldn't read /proc/self/task/139/stack)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   native: (backtrace::Unwind failed for thread 139)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   at com.android.internal.os.Zygote.nativeForkAndSpecialize(Native method)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   at com.android.internal.os.Zygote.forkAndSpecialize(Zygote.java:93)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   at com.android.internal.os.ZygoteConnection.runOnce(ZygoteConnection.java:225)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   at com.android.internal.os.ZygoteInit.runSelectLoop(ZygoteInit.java:706)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366]   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628)
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366] 
12-28 16:25:06.453: A/art(1198): art/runtime/runtime.cc:366] 
12-28 16:25:06.453: A/art(1198): --------- beginning of crash






/**
 * Native implementation of the service manager.  Most clients will only
 * care about getDefault() and possibly asInterface().
 * @hide
 */
public abstract class ServiceManagerNative extends Binder implements IServiceManager
{
    /**
     * Cast a Binder object into a service manager interface, generating
     * a proxy if needed.
     */
    static public IServiceManager asInterface(IBinder obj)
    {
        if (obj == null) {
            return null;
        }
        IServiceManager in =
            (IServiceManager)obj.queryLocalInterface(descriptor);
        if (in != null) {
            return in;
        }
        
        return new ServiceManagerProxy(obj);
    }
    
    public ServiceManagerNative()
    {
        attachInterface(this, descriptor);
    }
    
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
    {
        try {
            switch (code) {
            case IServiceManager.GET_SERVICE_TRANSACTION: {
                data.enforceInterface(IServiceManager.descriptor);
                String name = data.readString();
                IBinder service = getService(name);
                reply.writeStrongBinder(service);
                return true;
            }
    
            case IServiceManager.CHECK_SERVICE_TRANSACTION: {
                data.enforceInterface(IServiceManager.descriptor);
                String name = data.readString();
                IBinder service = checkService(name);
                reply.writeStrongBinder(service);
                return true;
            }
    
            case IServiceManager.ADD_SERVICE_TRANSACTION: {
                data.enforceInterface(IServiceManager.descriptor);
                String name = data.readString();
                IBinder service = data.readStrongBinder();
                boolean allowIsolated = data.readInt() != 0;
                addService(name, service, allowIsolated);
                return true;
            }
    
            case IServiceManager.LIST_SERVICES_TRANSACTION: {
                data.enforceInterface(IServiceManager.descriptor);
                String[] list = listServices();
                reply.writeStringArray(list);
                return true;
            }
            
            case IServiceManager.SET_PERMISSION_CONTROLLER_TRANSACTION: {
                data.enforceInterface(IServiceManager.descriptor);
                IPermissionController controller
                        = IPermissionController.Stub.asInterface(
                                data.readStrongBinder());
                setPermissionController(controller);
                return true;
            }
            }
        } catch (RemoteException e) {
        }
        
        return false;
    }

    public IBinder asBinder()
    {
        return this;
    }
}

class ServiceManagerProxy implements IServiceManager {
    public ServiceManagerProxy(IBinder remote) {
        mRemote = remote;
    }
    
    public IBinder asBinder() {
        return mRemote;
    }
    
    public IBinder getService(String name) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IServiceManager.descriptor);
        data.writeString(name);
        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);
        IBinder binder = reply.readStrongBinder();
        reply.recycle();
        data.recycle();
        return binder;
    }

    public IBinder checkService(String name) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IServiceManager.descriptor);
        data.writeString(name);
        mRemote.transact(CHECK_SERVICE_TRANSACTION, data, reply, 0);
        IBinder binder = reply.readStrongBinder();
        reply.recycle();
        data.recycle();
        return binder;
    }

    public void addService(String name, IBinder service, boolean allowIsolated)
            throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IServiceManager.descriptor);
        data.writeString(name);
        data.writeStrongBinder(service);
        data.writeInt(allowIsolated ? 1 : 0);
        mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);
        reply.recycle();
        data.recycle();
    }
    
    public String[] listServices() throws RemoteException {
        ArrayList<String> services = new ArrayList<String>();
        int n = 0;
        while (true) {
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            data.writeInterfaceToken(IServiceManager.descriptor);
            data.writeInt(n);
            n++;
            try {
                boolean res = mRemote.transact(LIST_SERVICES_TRANSACTION, data, reply, 0);
                if (!res) {
                    break;
                }
            } catch (RuntimeException e) {
                // The result code that is returned by the C++ code can
                // cause the call to throw an exception back instead of
                // returning a nice result...  so eat it here and go on.
                break;
            }
            services.add(reply.readString());
            reply.recycle();
            data.recycle();
        }
        String[] array = new String[services.size()];
        services.toArray(array);
        return array;
    }

    public void setPermissionController(IPermissionController controller)
            throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IServiceManager.descriptor);
        data.writeStrongBinder(controller.asBinder());
        mRemote.transact(SET_PERMISSION_CONTROLLER_TRANSACTION, data, reply, 0);
        reply.recycle();
        data.recycle();
    }

    private IBinder mRemote;
}
